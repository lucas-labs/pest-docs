import { InfoBox } from '@components';

# Getting Started with `pest`

In this chapter, we'll guide you through setting up a new project and creating a basic API using
pest.

## Installing the CLI

The first step is to install the pest CLI. Open your terminal and run:

```bash
pip install pest-cli
```

> Using the CLI is not mandatory, but it makes it easier to create new projects.
> It doesn't have to be a dependency of your project, you can install it globally.

## Creating a new project

Now that pest-cli is installed, let's kickstart our haunted-houses project:

```bash
pest generate application haunted-houses --dm poetry
```

This command creates a new pest project using poetry as the dependency manager. You need poetry
installed on your machine for this to work. If you don't have poetry installed and don't want to
install it, you can remove the `--dm poetry` flag and pest-cli will ask you which dependency manager
you want to use. By the time of writing this tutorial, pest-cli supports poetry and 
requirements.txt. If you prefer to use a requirements.txt file, you can then install the 
dependencies with `pip install -r requirements.txt` and you're good to go.

### Running the project

Now that the project is created, let's install the dependencies:

```bash
cd haunted-houses
poetry install
```

Now let's run the project:

```bash
poetry run uvicorn app.main:app --reload
INFO:     Will watch for changes in these directories: ['D:\\users\\lucas\\Desktop\\appp\\poetry']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

Open your browser and navigate to http://127.0.0.1:8000, you should see a Json response, similar to
this:

```json
{
    "hello": "pest!"
}
```

## Project structure

Let's take a look at the project structure generated by pest-cli:

```txt
app
 â”œâ”€ hello
 â”‚   â”œâ”€ greeter_service.py
 â”‚   â”œâ”€ hello_controller.py
 â”‚   â””â”€ module.py
 â”œâ”€ app_module.py
 â””â”€ main.py
```

### app_module.py

This file contains the main/root [module](../overview/modules.mdx) of the application.

It tells `pest` how to locate the controllers and services of the application.

The main module can import other controllers or services directly or import other modules that
define their own controllers and services. In this case, the `AppModule` imports the `HelloModule`,
a feature module that encapsulates the "greeting" feature of the application.

<InfoBox title="ðŸ“„ app_module.py">
    This is how the `app_module.py` file looks like:

    ```python
    from pest.decorators.module import module
    from .hello.module import HelloModule

    @module(
        imports=[HelloModule],
    )
    class AppModule:
        pass
    ```

    The `@module` decorator is used to define a module. The `imports` argument is used to import
    other modules into the current module. In this case, we're importing the `HelloModule` into the
    `AppModule`.
</InfoBox>

### hello/module.py

This a [feature module](../overview/modules.mdx#feature-modules). A feature module is a module that
encapsulates a specific feature of the application.

In this case, the `HelloModule` encapsulates the greeting feature, which is composed of a controller
`HelloController` and a service `GreeterService`.

<InfoBox title="ðŸ“„ hello/module.py">
    This is how the `hello/module.py` file looks like:

    ```python
    from pest import module
    from .greeter_service import GreeterService
    from .hello_controller import HelloController

    @module(
        controllers=[HelloController],
        providers=[GreeterService],
    )
    class HelloModule:
        pass
    ```

    The controller will define the routes of the application and the service will contain the
    business logic. Pest will inject the service and it will be available to inject inside all
    the controllers and providers of the module. In this small example, we only have one controller
    and one service, but you can have as many as you want.
</InfoBox>

### hello/greeter_service.py

This is a [provider](../overview/modules.mdx#providers). A provider or service, usually contains
the business logic of the application. 

While a controller is responsible for handling the request and returning a response on a set of
specific routes, a service is responsible for handling the business logic of the application.

So, usually, a controller will call a service to handle the business logic and return a response
to the client.

<InfoBox title="ðŸ“„ hello/greeter_service.py">
    This is how the `hello/greeter_service.py` file looks like:

    ```python
    from pydantic import BaseModel

    class Greet(BaseModel):
        """A greeting"""
        hello: str
        '''The greeting'''

    class GreeterService:
        """The haunted house service"""
        def say_hello(self) -> Greet:
            """Say hello"""
            return Greet(hello="pest!")
    ```

    This is just a simple service that returns a greeting.
</InfoBox>  

### hello/hello_controller.py

This is a [controller](../overview/modules.mdx#controllers). A controller is responsible for
handling the request and returning a response on a set of specific routes.

Pest will call the right route handler (a method of the controller) based on the HTTP method and
the path of the request.

Usually, a controller will call a service to handle the business logic and return a response
to the client.

<InfoBox title="ðŸ“„ hello/hello_controller.py">
    This is how the `hello/hello_controller.py` file looks like:

    ```python
    from pest import controller, get
    from .greeter_service import Greet, GreeterService

    @controller("/")
    class HelloController:
        """say hello routes"""
        service: GreeterService  # ðŸ’‰ injected

        @get("/")
        def say_hello(self) -> Greet:
            """Say hello"""
            return self.service.say_hello()
    ```

    This defines a controller with a single route handler. The route handler is called when a GET
    request is made to the root path of the application. The route handler calls the `say_hello`
    method of the `GreeterService` and returns its response.
</InfoBox> 

### main.py

This is the entrypoint of the application. It contains the `main` function that starts the
application. Remember when we ran `poetry run uvicorn app.main:app --reload`? The `app.main:app`
part tells uvicorn to look for the `app` module and the `app` variable inside the `main.py` file
and mount it as the root application.

## OpenAPI

Thanks to [FastAPI](https://fastapi.tiangolo.com/), pest automatically generates an OpenAPI
specification for your application and mounts a Swagger UI at `/docs` and a ReDoc UI at `/redoc`.

* [`/docs` - Swagger UI](http://localhost:8000/docs)
* [`/redoc` - ReDoc UI](http://localhost:8000/redoc)

## Conclusion

In this tutorial, we've learned how to create a new project using `pest-cli` and we've dive into
each file generated by it, learning how they collaborate to create a simple API.

In the folowing chapters we will modify this project to add more features and learn more about 
`pest`.
